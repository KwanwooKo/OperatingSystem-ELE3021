# Project03-wiki


## Multi Indirect

1. double indirect
2. triple indirect

둘이 사실상 같은 구조 이므로 한번에 진행하고자 한다.

![스크린샷 2023-06-16 오전 1.26.03.png](Project03-wiki%20f2d5feb724134d03947b441ffa456e2d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-16_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.26.03.png)

위의 그림은 double indirect의 구조이고 아래 그림은 triple indirect의 구조이다.

기존의 bmap 함수에서 DIRECT와 INDIRECT에 대해서 처리를 해주는데 double indirect와 triple indirect를 동일한 방식으로 추가한다.

bmap 함수에서 indirect인 경우에 어떻게 처리하는지를 봐야하는데 block number(bn)를 독립적으로 관리하는 것을 알 수 있다.

그 증거로 NDIRECT 영역을 벗어나는 경우

bn -= NDIRECT 를 해줘서 다시 0번 블록으로 시작하는 것처럼 보이도록 한다.

마찬가지로 double indirect와 triple indirect 구현과정에서도 동일하게 빼주는 작업을 해야한다.

double과 triple indirect를 구현하기 위해 사전에 값을 선언 했다.

![스크린샷 2023-06-16 오전 1.33.25.png](Project03-wiki%20f2d5feb724134d03947b441ffa456e2d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-16_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.33.25.png)

file block의 개수에 따라 각각 선언했다.

또한 dinode 및 inode 구조체의 값을 변경 했는데, 명세에서 제시된 것과 같이 d_addr과 t_addr 값을 추가했다.

다만 이 값을 추가할 경우 file system을 만드는 과정에서 dinode의 크기가 512의 약수인지 확인을 하는데 기존의 64byte가 72byte가 되어버려서 NDIRECT 값을 12에서 10으로 조정했다.

그리고 MAXFILE값도 변경을 해야하는데, 기존에 NDIRECT와 NINDIRECT만 있던 값에 NDINDIRECT와 NTINDIRECT 값을 추가해준다.

FSSIZE 값을 변경해야 하는데, 명세에서 제시된 대로 triple indirect까지 진행하게 되면 최대 1GB까지 관리를 할 수 있다.

그래서 File의 최대 블록 개수를 계산해보면 1GB / 512byte (1block의 크기가 512byte 이므로) 2097152개가 나오는 것을 알 수 있다.

bmap함수에서 bn 값을 찾기 위해 일반화된 식을 작성해볼 때 다음과 같은 식이 나오는 것을 알 수 있다

1. double indirect
    
    $$
    128*firstblock + secondblock
    $$
    
2. triple indirect

$$
128^2*firstblock + 128*secondblock + thirdblock
$$

이 식에 유의해서 bn값에서 적절하게 찾았다.

![스크린샷 2023-06-16 오전 2.04.58.png](Project03-wiki%20f2d5feb724134d03947b441ffa456e2d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-16_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_2.04.58.png)

이 코드는 bmap함수에서 INDIRECT의 경우를 처리하는 코드이다.

이와 동일하게 double과 triple을 구현했다.

double

![스크린샷 2023-06-16 오전 2.05.50.png](Project03-wiki%20f2d5feb724134d03947b441ffa456e2d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-16_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_2.05.50.png)

triple

![스크린샷 2023-06-16 오전 2.06.14.png](Project03-wiki%20f2d5feb724134d03947b441ffa456e2d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-16_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_2.06.14.png)

### Symbolic Link

기존의 link 기능은 hard link로 구현되어 있다.

hard link와 symbolic link 둘 다 구현해야 하므로 

ln.c 파일에서 argc 개수를 늘려주고 option에 따라 기존의 link 혹은 symbolic_link를 호출하도록 했다

symbolic link를 구현할 때, link되어 있는 file의 pathname을 기억하도록 하고, 해당 file의 path를 open할 때 바꿔치기 해서 열어야 한다.

그래서 sys_symbolic_link함수에서 ip를 새로 생성하고(create 함수 이용), 해당 ip가 symbolic인지 작성하고 이를 메모리에 기록해둔다.

sys_open에서 정상적으로 열려고 하는 파일을 열고, 해당 file이 symbolic인지 확인한다.

만약 symbolic이라면 path를 바꾸고 바뀐 path에 해당하는 ip를 가져온다.

그리고 그 ip에 맞게 file을 할당한다.

이 과정을 통해 symbolic link를 구현할 수 있다.

![스크린샷 2023-06-16 오전 2.07.00.png](Project03-wiki%20f2d5feb724134d03947b441ffa456e2d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-16_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_2.07.00.png)

위의 code는 sys_symbolic_link함수에 구현된 코드인데, ip를 생성하고 해당 ip가 symbolic임을 표시한 뒤 path를 복사한다.

![스크린샷 2023-06-16 오전 2.07.59.png](Project03-wiki%20f2d5feb724134d03947b441ffa456e2d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-16_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_2.07.59.png)

위의 code는 sys_open함수에 구현된 코드인데, path로 찾은 ip가 symbolic인 경우 그 ip를 link된 파일의 ip로 교체하는 과정이다.

### Sync

기존의 xv6 운영체제는 begin_op()와 end_op()를 이용해 작업들을 transaction처럼 관리한다.

이 때 write 하는 작업으로는

1. block에 기록하는 것
2. log에 기록하는 것

이렇게 2가지가 있다.

block의 값이 변경될 때마다 log에 기록하고 해당 write 작업이 끝나면 end_op에서 commit을 진행한다.

commit에서는 변경된 log를 disk에 기록한다.

이 group commit 과정을 buffer I/O 를 이용해 group flush로 변경해야 한다.

해당 기능을 구현하기 위해, 기존에 log를 작성하던 과정을 다 지우고 commit함수에서 처리하도록 했다.

또한 buffer가 가득 찼을 때, 해당 buffer를 비워줘야 하는데 buffer에 block을 등록하는 과정이 bget함수에 구현되어 있기 때문에 bget함수에서 panic이전에 sync를 호출하고 다시 buffer에 block을 등록해서 반환하도록 처리했다.

다만, 해당 함수에서 분명 sync함수가 호출돼야 하는데 sync가 호출되지 않는 문제가 발생했다.

test code를 작성했을 때, 정상적으로 작동하는지 확인을 해봤을 때 write는 잘 되지만 close하고 다시 open할 때에 file descriptor 값을 읽지 못하는 문제가 발생했다.

이 원인을 도저히 모르겠어서 해당 과정의 구현을 중단했다.

해당 기능을 구현한 부분을 제출하지 않는 이유는 기존의 multi indirect와 symbolic link 기능이 작동하지 않아 앞의 2개의 구현에 대한 점수감점이 이뤄질 것 같아 local에서만 구현했습니다.

### Trouble shooting

1. Multi indirect

해당 부분을 구현할 때 매크로에 괄호를 치지 않아 block number가 이탈하는 문제가 발생했다. 단순히 이거 문제일까 하고 괄호를 쳐봤는데 정상적으로 작동해서 해결하였다.

1. Symbolic link

원래는 명세에서 주어진 대로 file의 ip에서 symbolic한 파일의 ip를 가리키게 하려고 했는데, 해당 기능이 정상적으로 작동지 않아서 결국 수업시간에 들었던 path를 저장하는 방식으로 처리했다.

### Multi indirect

![스크린샷 2023-06-16 오전 2.12.41.png](Project03-wiki%20f2d5feb724134d03947b441ffa456e2d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-16_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_2.12.41.png)

16MB 파일을 쓰고 읽는 테스트를 구현했다.

### Symbolic link

![스크린샷 2023-06-16 오후 11.38.25.png](Project03-wiki%20f2d5feb724134d03947b441ffa456e2d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-16_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.38.25.png)

helloworld 파일을 hello라는 파일과 symbolic하게 연결을 한 상태이다.

![스크린샷 2023-06-16 오후 11.38.58.png](Project03-wiki%20f2d5feb724134d03947b441ffa456e2d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-16_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.38.58.png)

hello, helloworld 둘 다 정상적으로 실행되는 것을 볼 수 있다.

![스크린샷 2023-06-16 오후 11.42.08.png](Project03-wiki%20f2d5feb724134d03947b441ffa456e2d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-16_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.42.08.png)

원본 파일을 삭제하고 hello를 다시 실행하면 실행이 안되는 것을 볼 수 있다

![스크린샷 2023-06-16 오후 11.40.07.png](Project03-wiki%20f2d5feb724134d03947b441ffa456e2d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-16_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.40.07.png)

ls를 실행했을 때 정상적으로 hello가 인식되는 것을 볼 수 있다.
